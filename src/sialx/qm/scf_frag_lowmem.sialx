import "trans_frag_defs.sialx" 
import "mcpt2_vars.sialx"
#
                           SIAL SCF_FRAGMENT 

      PROC SET_FRAG_PARMS    
#     ------------------- 
#
#     Determine the number of fragments  
#     --------------------------------- 
      execute set_frag n_frags

      do kfrag
      do jfrag
	  where jfrag <= kfrag
	  icount = (scalar)kfrag
	  jcount = (scalar)jfrag

          execute return_pairs icount jcount elst_thresh pair_flag 
	  elst_dist[kfrag,jfrag] = 0.0
	  elst_dist[jfrag,kfrag] = 0.0

          if pair_flag > zero
	  elst_dist[kfrag,jfrag] = (scalar)kfrag
	  elst_dist[jfrag,kfrag] = (scalar)jfrag
	  endif

          execute return_pairs icount jcount r_thresh pair_flag 
	  rcut_dist[kfrag,jfrag] = 0.0
	  rcut_dist[jfrag,kfrag] = 0.0

          if pair_flag > zero
	  rcut_dist[kfrag,jfrag] = (scalar)kfrag
	  rcut_dist[jfrag,kfrag] = (scalar)jfrag
	  endif

      enddo jfrag
      enddo kfrag

      do jfrag
#
	  icount = (scalar)jfrag
          i_aostart = icount
          i_aoend   = 1.0
          execute frag_index_range i_aostart i_aoend
         i_vstart  = icount
         i_vend    = 6.0
         execute frag_index_range i_vstart i_vend
         a_vstart  = icount
         a_vend    = 7.0
         execute frag_index_range a_vstart a_vend

          m = 0.0
          do mu
              m += 1.0
              if m >= i_aostart
              if m <= i_aoend
              SwAO_frag[(index)mu] = (scalar)jfrag
              endif
              endif
          enddo mu
         DO i
            m = 0.0
            do i1
               m += 1.0
               if i == i1
                  exit
               endif
            enddo i1
            if m >= i_vstart
            if m <= i_vend
               SwOccA_frag[(index)i] = (scalar)jfrag
            endif
            endif
         ENDDO i
         DO a
            m = 0.0
            do a1
               m += 1.0
               if a == a1
                  exit
               endif
            enddo a1
            if m >= a_vstart
            if m <= a_vend
               SwVirtA_frag[(index)a] = (scalar)jfrag
            endif
            endif
         ENDDO a
      enddo jfrag

      sip_barrier
      ENDPROC SET_FRAG_PARMS    
#
      PROC IGUESS   
#     ----------- 
#
#     Get memory requirements from integral calculation 
#     ------------------------------------------------- 
      print "Starting scratch memory calculation" 
      imax = 0.0  
      zmax = 0.0  
      execute compute_int_scratchmem_lowmem zmax imax 
      sip_barrier 
      print "Done computing scratch memory" 
#
      sip_barrier 
      allocate contiguous scr_1[1:max_aoseg,1:max_aoseg]
      allocate contiguous scr_2[1:max_aoseg,1:max_aoseg]
      allocate contiguous scr_3[1:max_aoseg,1:max_aoseg]
      allocate contiguous scr_4[1:max_aoseg,1:max_aoseg]
      allocate contiguous scr_5[1:max_aoseg,1:max_aoseg]
      sip_barrier 

    PARDO katom  
	icount = (scalar)katom

#	print icount # etemp 

	print "Starting computing fragment scf" 
	execute scf_atom_lowmem icount scr_1[1:max_aoseg,1:max_aoseg] scr_2[1:max_aoseg,1:max_aoseg] scr_3[1:max_aoseg,1:max_aoseg] scr_4[1:max_aoseg,1:max_aoseg]
	print "Done computing fragment scf" 
#
# Nowput the coefficients and fock matrices into the full distributed arrays 

	stype = 1.0 # HF coefficients  
	DO mu
	where (int)SwAO_frag[(index)mu] == katom
	    DO a
	    where (int)SwVirtA_frag[(index)a] == katom
		txp[mu,a]      = 0.0  
		execute place_scratch txp[mu,a]  scr_1[1:max_aoseg,1:max_aoseg] stype icount 
		PUT DCa[mu,a] += txp[mu,a]
	    ENDDO a
	    DO i
	    where (int)SwOccA_frag[(index)i] == katom
		txp[mu,i]      = 0.0  
		execute place_scratch txp[mu,i]  scr_1[1:max_aoseg,1:max_aoseg] stype icount  
		PUT DCa[mu,i] += txp[mu,i]
	    ENDDO i
	ENDDO mu
	print "Done placing coefficients"

	stype = 2.0 # Fock matrix  
	DO a   
	where (int)SwVirtA_frag[(index)a] == katom
	    DO a1
	    where (int)SwVirtA_frag[(index)a1] == katom
		tpp[a,a1]          = 0.0  
		execute place_scratch tpp[a,a1]  scr_3[1:max_aoseg,1:max_aoseg] stype icount 
		PUT Dfock_a[a,a1] += tpp[a,a1] 
	    ENDDO a1
	    DO i1
	    where (int)SwOccA_frag[(index)i1] == katom
		tpp[a,i1]          = 0.0  
		execute place_scratch tpp[a,i1]  scr_3[1:max_aoseg,1:max_aoseg] stype icount 
		PUT Dfock_a[a,i1] += tpp[a,i1] 
	    ENDDO i1
	ENDDO a   

	DO i   
	where (int)SwOccA_frag[(index)i] == katom
	    DO i1
	    where (int)SwOccA_frag[(index)i1] == katom
		tpp[i,i1]          = 0.0  
		execute place_scratch tpp[i,i1]  scr_3[1:max_aoseg,1:max_aoseg] stype icount 
		PUT Dfock_a[i,i1] += tpp[i,i1]
	    ENDDO i1
	    DO a1
	    where (int)SwVirtA_frag[(index)a1] == katom
		tpp[i,a1]          = 0.0  
		execute place_scratch tpp[i,a1]  scr_3[1:max_aoseg,1:max_aoseg] stype icount 
		PUT Dfock_a[i,a1] += tpp[i,a1]
	    ENDDO a1
	ENDDO i

#                 DO p 
#                 DO p1 
#                    tpp(p,p1) = 0.0 
#                    execute place_scratch tpp(p,p1)  scratch3 stype  
#                    PUT Dfock_a(p,p1) += tpp(p,p1)
#                 ENDDO p1 
#                 ENDDO p 
	print "Done placing fock_matrix"


    ENDPARDO katom   
      sip_barrier 
      deallocate contiguous scr_1[1:max_aoseg,1:max_aoseg]
      deallocate contiguous scr_2[1:max_aoseg,1:max_aoseg]
      deallocate contiguous scr_3[1:max_aoseg,1:max_aoseg]
      deallocate contiguous scr_4[1:max_aoseg,1:max_aoseg]
      deallocate contiguous scr_5[1:max_aoseg,1:max_aoseg]
      sip_barrier 
#
      ENDPROC IGUESS   

# -----------------------------------------------------------------------------
# 
#     START OF MAIN PROGRAM  
#
# -----------------------------------------------------------------------------

      CALL SET_FRAG_PARMS   
      sip_barrier 
      print "Done setting fragment parameters" 
      print "Performing monomer SCF"
      call IGUESS
      sip_barrier 

      set_persistent Dca "ca" 
      set_persistent DFock_a "fock_a"

# -----------------------------------------------------------------------------
#
                           ENDSIAL SCF_FRAGMENT 
#
###############################################################################
