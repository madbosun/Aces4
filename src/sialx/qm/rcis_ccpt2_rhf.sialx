#  import "cis_rhf_defs.sialx" 
  import "reom_rhf_defs.sialx"
                           SIAL CCSD_RHF_SV1
#
#-------------------------------------------------------------------------------
#
# Declare indeces 
# --------------- 
#
      index kiter    = 1: cc_iter   
      index   kbeg   = 1: scf_beg # Change to cc_beg 
      index   korder = 1: scf_hist # Change to cc_hist 
      index   kone   = 1: 1
      index   kdiis  = 1: 30 
      index   k1diis = 1: 30 
      index   jdiis  = 1: 30 
      index   j1diis = 1: 30 
      index      D1  = 1: 30 
      index      D2  = 1: 30 
      index kstate   = 1: eom_roots
      index kstate1  = 1: eom_roots
      index ksub  = 1: eom_subspc
      index ksub1 = 1: eom_subspc
#
      aoindex mu     = 1: norb 
      aoindex nu     = 1: norb
      aoindex lambda = 1: norb
      aoindex sigma  = 1: norb
#
      moaindex i = baocc: eaocc
      moaindex i1= baocc: eaocc
      moaindex i2= baocc: eaocc
      moaindex i3= baocc: eaocc
#
      moaindex a = bavirt: eavirt
      moaindex a1= bavirt: eavirt
      moaindex a2= bavirt: eavirt
      moaindex a3= bavirt: eavirt
#
      moaindex j = baocc: eaocc
      moaindex j1= baocc: eaocc
      moaindex j2= baocc: eaocc
      moaindex j3= baocc: eaocc
#
      moaindex b = bavirt: eavirt
      moaindex b1= bavirt: eavirt
      moaindex b2= bavirt: eavirt
      moaindex b3= bavirt: eavirt
#
      moaindex p = baocc: eavirt
      moaindex p1= baocc: eavirt
      moaindex p2= baocc: eavirt
      moaindex p3= baocc: eavirt
#
      moaindex q = baocc: eavirt
      moaindex q1= baocc: eavirt
      moaindex q2= baocc: eavirt
      moaindex q3= baocc: eavirt
# 
# Declare static arrays 
# --------------------- 
#
      distributed t1a_old[a,i] 
      distributed t1a_new[a,i] 
#
      distributed Fae_a[a,a1] 
      distributed Fme_a[i,a] 
      distributed Fmi_a[i,i1] 
      distributed DCa[mu,p] 
      distributed FTa[p,p1] 

      static zz[mu,nu] 
#
# Arrays used in the DIIS 
# -----------------------
#
      served Daibj[a,i,b,j,kdiis] 
      served Eaibj[a,i,b,j,jdiis] 
      distributed Dai[a,i,kdiis] 
      distributed Eai[a,i,jdiis] 
      served D0aibj[a,i,b,j] 
      served D0ai[a,i] 

      temp Taibjk[a,i,b,j,kdiis] 
      static BB[d1,d2] 
      temp tbb[d1,d2] 
      distributed DIST_BB[d1,d2] 
      scalar imax
      scalar zmax
      scalar n1 
      scalar n2 
      scalar worder  
#
# Arrays used in transformation for AO2 algorithm
# -----------------------------------------------
#
      served VSpipi[p1,i,p,i1]
      served Viaai[i,a1,a,i1] 
      served Vaaii[a,a1,i,i1]
      served Vaaai[a2,a,a1,i]
#
      temp Txixj[mu,i,nu,j]
      served Vpiqj[p,i,q,j]
#
# End Arrays used in transformation for AO2 algorithm
# --------------------------------------------------- 
#
# Declare temporary arrays 
# ------------------------ 
#
      temp Txjjx[mu,j,j1,nu]
      temp Txijx[mu,i,j,nu]
      temp Txqii[mu,q,i,i1]
      temp Tqqii[q,q1,i,i1]
      temp Txpjj[mu,p,j,j1]
      temp Txqjj[mu,q,j,j1]
      temp Tppjj[p,p1,j,j1]
      temp Tqqjj[q,q1,j,j1]
      temp Tjxqj[j,mu,q,j1]
      temp Tjqqj[j,q,q1,j1]
      temp Tixqj[i,mu,q,j]
      temp Tipqj[i,p,q,j]
#
      temp Taiai[p,i,p1,i1]
      temp T1aiai[p,i,p1,i1]
      temp T2aiai[p,i,p1,i1]
      temp T3aiai[p,i,p1,i1]
      temp Tbjbj[q,j,q1,j1]
      temp T1bjbj[q,j,q1,j1]
      temp T2bjbj[q,j,q1,j1]
      temp T3bjbj[q,j,q1,j1]
      temp Taibj[p,i,q,j]
      temp T1aibj[p,i,q,j]
      temp T2aibj[p,i,q,j]
      temp T3aibj[p,i,q,j]
      temp T4aibj[p,i,q,j]
      temp T5aibj[p,i,q,j]
#
      temp Txxxp[mu,nu,lambda,i]
      temp Txxxq[mu,nu,lambda,j]
      temp Txxpp[mu,nu,p1,i]
      temp Txxqq[mu,nu,q1,j]
      temp Txppp[mu,p2,p1,i]
      temp Txqpp[mu,q,p1,i]
      temp Txqqq[mu,q2,q1,j]
      temp Txpqq[mu,p,q1,j]
      temp Tpppp[p3,p2,p1,p]
      temp Tqqqq[q3,q2,q1,q]
      temp Tppqq[p1,p,q1,j]
      temp Tqqpp[q1,q,p1,i]
      temp Tixxx[i,mu,nu,sigma] 
      temp Tipxx[i,p,nu,sigma] 
      temp Tipqx[i,p,q,sigma] 
      temp Tipqq[i,p,q,q1] 
      temp Txiai[lambda,i,a1,i1] 
      temp Txjbj[lambda,j,b1,j1] 
      temp Txibj[lambda,i,b1,j1] 
#
      temp tmp1_aiai[a,i,a1,i1] 
      temp tmp2_aiai[a,i,a1,i1] 
      temp tmp3_aiai[a,i,a1,i1] 
      temp tmp1_aibj[a,i,b,j] 
      temp tmp2_aibj[a,i,b,j] 
#
      temp Tai[a,i] 
      temp T1ai[a,i] 
      temp T2ai[a,i] 
      temp T3ai[a,i] 
      temp Tbj[b,j] 
      temp T1bj[b,j] 
      temp T2bj[b,j] 
#
      temp Taa[a,a1] 
      temp T1aa[a,a1] 
      temp T1bb[b,b1] 
      temp Tae_a[a,a1] 
      temp Tae_b[b,b1] 
#
      temp Tia[i,a] 
      temp T1ia[i,a] 
      temp Tjb[j,b] 
      temp T1jb[j,b] 
      temp Tme_a[i,a] 
      temp Tme_b[j,b] 
#
      temp Tii[i,i1] 
      temp T1ii[i,i1] 
      temp Tjj[j,j1] 
      temp T1jj[j,j1] 
      temp Tmi_a[i,i1] 
      temp Tmi_b[j,j1] 
#
      temp T1pppp[p,p1,p2,p3] 
      temp T1qqqq[q,q1,q2,q3] 
      temp Taiii[a,i,i1,i2] 
      temp T1aiii[a,i,i1,i2] 
#
      temp  Tiiii[i,i1,i2,i3] 
      temp T1iiii[i,i1,i2,i3] 
#
      temp  Tjjjj[j,j1,j2,j3] 
      temp T1jjjj[j,j1,j2,j3] 
      temp  Tbjjj[b,j,j1,j2] 
      temp T1bjjj[b,j,j1,j2] 
#
      temp  Tiijj[i,i1,j2,j3] 
      temp T1iijj[i,i1,j2,j3] 
#
      temp  tmp_aa[a,a1] 
      temp tmp1_aa[a,a1] 
      temp  tmp_ii[i,i1] 
      temp tmp1_ii[i,i1] 
#
      temp  Tiiai[i,i1,a,i2] 
      temp T1iiai[i,i1,a,i2] 
#
      temp  tmp_bb[b,b1] 
      temp tmp1_bb[b,b1] 
      temp  tmp_jj[j,j1] 
      temp tmp1_jj[j,j1] 
#
      temp  Tjjbj[j,j1,b,j2] 
      temp T1jjbj[j,j1,b,j2] 
# 
      temp T1aaai[a,a1,a2,i]  
      temp T2aaai[a,a1,a2,i]  
      temp Taaaa[a,a1,a2,a3]  
      temp T1aaaa[a,a1,a2,a3]  
#
      temp T1bbbj[b,b1,b2,j]  
      temp T2bbbj[b,b1,b2,j]  
      temp Tbbbb[b,b1,b2,b3]  
      temp T1bbbb[b,b1,b2,b3]  
#
      temp Taabb[a,a1,b,b1]  
      temp T1aabb[a,a1,b,b1]  
#
      temp R1aiai[a,i,a1,i1] 
      temp R2aiai[a,i,a1,i1] 
      temp R3aiai[a,i,a1,i1] 
      temp R4aiai[a,i,a1,i1] 
      temp R1bjbj[b,j,b1,j1] 
      temp R2bjbj[b,j,b1,j1] 
      temp R3bjbj[b,j,b1,j1] 
      temp R4bjbj[b,j,b1,j1] 
      temp R1aibj[a,i,b,j] 
      temp R2aibj[a,i,b,j] 
      temp R3aibj[a,i,b,j] 
      temp R4aibj[a,i,b,j] 
#
      temp T1iaai[i,a,a1,i1] 
      temp T2iaai[i,a,a1,i1] 
      temp T1jbbj[j,b,b1,j1] 
      temp T2jbbj[j,b,b1,j1] 
      temp T1iabj[i,a,b,j] 
      temp T2iabj[i,a,b,j] 
      temp Tjjpp[j,j1,p,p1] 
      temp T1jjpp[j,j1,p,p1] 
      temp T2jjpp[j,j1,p,p1] 
      temp  Tiiqq[i,i1,q,q1] 
      temp T1iiqq[i,i1,q,q1] 
      temp T2iiqq[i,i1,q,q1] 
      temp  Tjjai[j,j1,a,i] 
      temp T1jjai[j,j1,a,i] 
      temp T2jjai[j,j1,a,i] 
      temp  Tiibj[i,i1,b,j] 
      temp T1iibj[i,i1,b,j] 
      temp T2iibj[i,i1,b,j] 
      temp  Tjbai[j,b,a,i]  
      temp T1jbai[j,b,a,i]  
      temp T2jbai[j,b,a,i]  
      temp  Taijj[a,i,j,j1] 
      temp T1aijj[a,i,j,j1] 
      temp Tqqip[a,i,b,b1]  
#
      temp tpx[p,mu] 
      temp t1px[p,mu] 
      temp tqx[q,mu] 
      temp t1qx[q,mu] 
      temp txi[mu,i] 
      temp t1xi[mu,i] 
      temp txj[mu,j] 
      temp t1xj[mu,j] 
#
# Declare distributed arrays 
# -------------------------- 
#
      served T2new_ab[a,i,b,j]
      served T2old_aa[a,i,a1,i1]
      served T2old_ab[a,i,b,j]
#
      served Tau_ab[a,i,b,j]
      served Taup_aa[a,i,a1,i1]
      served Taup_ab[a,i,b,j]
#
      served Wiibb[i1,i,b,b1]    
      served Wjjaa[j1,j,a,a1]      
#
# CIS
      scalar ecorr2
      scalar shift
      scalar rank
      scalar esum2
      scalar esum3
      scalar edoubles
      scalar etriples
      scalar ecisccpt2
      scalar kroot
#
      static Ek[kstate]
      static Ekd[kstate]
      static SCai[a,i]
#
      served M2old_ab[a,i,b,j]
      served ck0[kstate,a,i]
      served Cai[a,i]
      served Cai_ao[mu,i]
      served Faa[a,a1]
      served Fii[i,i1]
      served Fai[a,i]
      served SFai[a,i]
      served Ctau[a,i,b,j]
      served Ctau_ao[mu,i,lambda,j]
      served CT_ab[a,i,b,j]
#
      temp Tk[kstate]
      temp Tkai[kstate,a,i]
      temp T1kai[kstate,a,i]
      temp Tpp[p,p1]
      temp T1pp[p,p1]
      temp T2pp[p,p1]
#
# Declare served arrays 
# --------------------- 
#
      scalar ncount1
      scalar ncount2
      scalar jcount 
      scalar kcount 
      scalar niter 
      scalar diis_start 
      scalar diis_order  
      scalar temp_order
      scalar zero
      scalar one
      scalar two
      scalar five
      scalar six
      scalar seven
#
# Arrays needed for AOLADDER contribution
# ---------------------------------------
#
     temp Zab[lambda,i,b,j]
     temp Yab[lambda,i,mu,j]
     temp Y1ab[lambda,i,mu,j]
#
     temp TXaiai[a,i,nu,i1]
     temp Taixi[a,i,nu,i1]   
     temp TYaiai[a,i,a1,i1]
     temp TY1aiai[a,i,a1,i1]
     temp TXbjbj[b,j,nu,j1]
     temp Tbjxj[b,j,nu,j1]
     temp TYbjbj[b,j,b1,j1]
     temp TY1bjbj[b,j,b1,j1]
     temp TXaibj[a,i,nu,j]
     temp TZaibj[a,i,nu,j]
     temp Taixj[a,i,nu,j]
     temp T1aixj[a,i,nu,j]
     temp TYaibj[a,i,b,j]
#
     served TAO_ab[lambda,i,sigma,j]
     served T2AO_ab[lambda,i,sigma,j]
     distributed t1a_ax[a,mu] 
     distributed t1a_xi[mu,i] 
     distributed t1b_xj[mu,j] 
     served TDaixj[a,i,nu,j]
     local LDaixj[a,i,nu,j] 
#
      served Vxxxi[mu,nu,lambda,i]
      served Vxixi[mu,i1,lambda,i]
      served Vxxii[mu,nu,i1,i]
      served Vixxi[i1,nu,lambda,i]
      served Vxipi[mu,i,p,i1]
      served Vixai[i,mu,a,i1]
      served Vxaii[mu,a,i,i1]
      served Vxaai[mu,a1,a,i]
      served Vxxai[mu,nu,a,i]
      served Vxixj[mu,i,nu,j]
      served Vxiqj[mu,i,q,j]
      temp aoint[mu,nu,lambda,sigma]
      temp Txixi[mu,i1,lambda,i]
      temp Txxii[mu,nu,i1,i]
      temp Tixxi[i1,nu,lambda,i]
      temp Txipi[mu,i,p,i1]
      temp T1xipi[mu,i,p,i1]
      temp Tpipi[p1,i,p,i1]
      temp T1pipi[p1,i,p,i1]
      temp Tixai[i,mu,a,i1]
      temp Txaii[mu,a,i,i1]
      temp Tiaai[i,a1,a,i1]
      temp Taaii[a,a1,i,i1]
      temp Txaai[mu,a1,a,i]
      temp Taaai[a2,a,a1,i]
      temp Txxai[mu,nu,a,i]
      temp T1xaai[mu,a1,a,i] 
      temp T1xxxi[mu,nu,lambda,i]  
      temp T1xixi[mu,i,nu,i1]
      temp Txiix[mu,i,i1,nu]
      temp Txpii[mu,p,i,i1]
      temp Tppii[p,p1,i,i1]
      temp Tixpi[i,mu,p,i1]
      temp Tippi[i,p,p1,i1]
#
      local Lxxxi[mu,nu,lambda,i]
      local Lxxai[mu,nu,a,i] 
      local Lxaai[mu,a1,a,i] 
#
# Declare scalars 
# --------------- 
#
      scalar etemp
      scalar esum
      scalar esuma
      scalar esumb
      scalar esumab
      scalar ecorraa
      scalar ecorrbb
      scalar ecorrab
      scalar ecorrT
      scalar enew 
      scalar eold 
      scalar ecrit 
      scalar ediff 
      scalar lccd_energy
      scalar restart
#
# Arrays/Scalars used exclusively in DIIS procedure. 
# -------------------------------------------------- 
#
       served e1aibj[a,i,b,j]  
       served e2aibj[a,i,b,j]  
       served e3aibj[a,i,b,j]  
       served e4aibj[a,i,b,j]  
       served e5aibj[a,i,b,j]  
       served e6aibj[a,i,b,j]  
#
       served e5aiai[a,i,b,j] 
       contiguous local CISCCPT2_EE_Energy[kstate]
       int master
#
#    ------------------------------------------------------------------------ 
    PROC read_2el

    restore_persistent ca "ca"
    restore_persistent Fock_a "fock_a"
    restore_persistent ck0 "C1_a"
    restore_persistent Ek "CIS_E"
    restore_persistent M2old_ab "T2old_ab"
    restore_persistent VSpipi "VSpipi"
    restore_persistent Vpiqj  "Vpiqj"
    restore_persistent Vaaii  "Vaaii"
    restore_persistent Viaai  "Viaai"
#

    ENDPROC read_2el
#
      proc setroot
#
      execute get_my_rank rank
      if rank == 0.0
      Tk[kstate] = 1.0
      do a
      do i
          request ck0[kstate,a,i] 
          Tai[a,i] = ck0[kstate,a,i]*Tk[kstate]
          SCai[a,i] = Tai[a,i]
      enddo i
      enddo a
      endif
      server_barrier

      server_barrier
      endproc setroot
#
#    ------------------------------------------------------------------------ 
    PROC IGUESS_UHF
    pardo a,b,i,j
#
        request M2old_ab[a,i,b,j] 
        Taibj[a,i,b,j] = M2old_ab[a,i,b,j]
        prepare T2old_ab[a,i,b,j] = Taibj[a,i,b,j]
        prepare D0aibj[a,i,b,j] = Taibj[a,i,b,j]
#
    endpardo a,b,i,j
    server_barrier
    pardo a,i,b,j
         request T2old_ab[a,i,b,j] 
         request T2old_ab[a,j,b,i] 
         Taibj[a,i,b,j]  = T2old_ab[a,i,b,j]
         T1aibj[a,i,b,j] = T2old_ab[a,j,b,i]
         Taibj[a,i,b,j] -= T1aibj[a,i,b,j]
         prepare T2old_aa[a,i,b,j] = Taibj[a,i,b,j]
     endpardo a,i,b,j
     server_barrier
#
    ENDPROC IGUESS_UHF
#
    PROC energy_start
#
    ecorrab = 0.0
    esumab  = 0.0
    server_barrier
    pardo a,i,b,j
#
        request Vpiqj[a,i,b,j] 
        request Vpiqj[a,j,b,i] 
#
        request M2old_ab[a,i,b,j] 
        Taibj[a,i,b,j] = M2old_ab[a,i,b,j]
#
        T1aibj[a,i,b,j]  = Vpiqj[a,i,b,j]
        T2aibj[a,i,b,j]  = Vpiqj[a,j,b,i]
        T1aibj[a,i,b,j] *= 2.0
        T1aibj[a,i,b,j] -= T2aibj[a,i,b,j]
#
        etemp = Taibj[a,i,b,j]*T1aibj[a,i,b,j]
        esumab += etemp
#
    endpardo a,i,b,j
    server_barrier
#
    collective ecorrab += esumab
    ecorrT = ecorrab
#
    server_barrier
    ENDPROC energy_start
#
    PROC energy
#
    ecorrab = 0.0
    esumab  = 0.0
    server_barrier
    pardo a,i,b,j
#
        request Vpiqj[a,i,b,j] 
        request Vpiqj[a,j,b,i] 
#
        request T2old_ab[a,i,b,j] 
        Taibj[a,i,b,j] = T2old_ab[a,i,b,j]
#
        T1aibj[a,i,b,j]  = Vpiqj[a,i,b,j]
        T2aibj[a,i,b,j]  = Vpiqj[a,j,b,i]
        T1aibj[a,i,b,j] *= 2.0
        T1aibj[a,i,b,j] -= T2aibj[a,i,b,j]
#
        etemp = Taibj[a,i,b,j]*T1aibj[a,i,b,j]
        esumab += etemp
#
    endpardo a,i,b,j
    server_barrier
#
    collective ecorrab += esumab
    ecorrT = ecorrab
    ecorrT += ecisccpt2
    print ecorrT
#
    server_barrier
    ENDPROC energy
#
#
     proc Caibj
#
     pardo a,i,b,j
         Taiai[a,i,b,j] = 0.0
         prepare Ctau[a,i,b,j] = Taiai[a,i,b,j]
         prepare CT_ab[a,i,b,j] = Taiai[a,i,b,j]
     endpardo a,i,b,j
     pardo mu,i
         Txi[mu,i] = 0.0
         prepare Cai_ao[mu,i] = Txi[mu,i]
     endpardo mu,i
     pardo mu,i,lambda,j
         Txixi[mu,i,lambda,j] = 0.0
         prepare Ctau_ao[mu,i,lambda,j] = Txixi[mu,i,lambda,j]
     endpardo mu,i,lambda,j
     server_barrier
#
# back transform CIS vector
     pardo a,i
#         request Cai(a,i) i
         do mu
             Txi[mu,i] = SCai[a,i]*ca[mu,a]
             prepare Cai_ao[mu,i] += Txi[mu,i]
         enddo mu
     endpardo a,i
#
     server_barrier
#
     pardo mu,nu,lambda

          allocate Lxxxi[mu,nu,lambda,*]
          DO sigma
             execute compute_integral_batch aoint[mu,nu,lambda,sigma]
             DO i   
                 T1xxxi[mu,nu,lambda,i]  = aoint[mu,nu,lambda,sigma]*ca[sigma,i]
                 Lxxxi[mu,nu,lambda,i]  += T1xxxi[mu,nu,lambda,i]
             ENDDO i
          ENDDO sigma

          do i
              request Cai_ao[nu,i] 
          do j

              Txixi[mu,i,lambda,j] = Cai_ao[nu,i]*Lxxxi[mu,nu,lambda,j]
              prepare Ctau_ao[mu,i,lambda,j] += Txixi[mu,i,lambda,j]

          enddo j
          enddo i

          deallocate Lxxxi[mu,nu,lambda,*]

     endpardo mu,nu,lambda
#
     server_barrier
     pardo a,i,b,j
         Taiai[a,i,b,j] = 0.0
         do i1
             request Vpiqj[i1,i,b,j] 
#             request cai(a,i1) a
             T1aiai[a,i,b,j] = Vpiqj[i1,i,b,j]*SCai[a,i1]
             Taiai[a,i,b,j] += T1aiai[a,i,b,j]
         enddo i1
         Taiai[a,i,b,j] *= -1.0
         prepare Ctau[a,i,b,j] += Taiai[a,i,b,j]
     endpardo a,i,b,j

     pardo nu,i,j

              allocate LDaixj[*,i,nu,j]
#
              DO mu
#
                 REQUEST Ctau_ao[mu,i,nu,j] 
#
                 DO a
                    Taixj[a,i,nu,j]   = Ctau_ao[mu,i,nu,j]*ca[mu,a]
                    LDaixj[a,i,nu,j] += Taixj[a,i,nu,j]
                 ENDDO a
#
              ENDDO mu

              DO a
              DO b
                 Taibj[a,i,b,j]             = LDaixj[a,i,nu,j]*ca[nu,b]
                 PREPARE Ctau[a,i,b,j] += Taibj[a,i,b,j]
              ENDDO b
              ENDDO a
#
              deallocate LDaixj[*,i,nu,j]

     endpardo nu,i,j

     server_barrier
     pardo a,i,b,j
         request Ctau[a,i,b,j] 
         request Ctau[b,j,a,i] 
         Taiai[a,i,b,j]  = Ctau[a,i,b,j]
         T1aiai[a,i,b,j] = Ctau[b,j,a,i]
         Taiai[a,i,b,j] += T1aiai[a,i,b,j]
         prepare CT_ab[a,i,b,j] = Taiai[a,i,b,j]
     endpardo a,i,b,j
     server_barrier
     pardo a,i,b,j
         request CT_ab[a,i,b,j] 
         Taibj[a,i,b,j] = CT_ab[a,i,b,j]
         execute energy_denominator_rhf Taibj[a,i,b,j] fock_a
         prepare T2old_ab[a,i,b,j] += Taibj[a,i,b,j]
         prepare D0aibj[a,i,b,j] += Taibj[a,i,b,j]
     endpardo a,i,b,j
     server_barrier
#
     endproc Caibj
#
     proc hbar_ab
#
     pardo a,i,b,j
#
         Tpp[a,b] = 0.0
         do a1
             request VSpipi[b,i,a1,j] 
             request T2old_aa[a,i,a1,j] 
             T1pp[a,b] = VSpipi[b,i,a1,j]*T2old_aa[a,i,a1,j]
             Tpp[a,b] += T1pp[a,b]
         enddo a1
         Tpp[a,b] *= -0.5
         prepare Faa[a,b] += Tpp[a,b]
#
     endpardo a,i,b,j
     pardo a,i,b,j
#
         Tpp[a,b] = 0.0
         do a1
             request Vpiqj[b,i,a1,j] 
             request T2old_ab[a,i,a1,j] 
             T1pp[a,b] = Vpiqj[b,i,a1,j]*T2old_ab[a,i,a1,j]
             Tpp[a,b] += T1pp[a,b]
         enddo a1
         Tpp[a,b] *= -1.0
         prepare Faa[a,b] += Tpp[a,b]
#
     endpardo a,i,b,j
#
     server_barrier
     endproc hbar_ab
#
     proc hbar_ij
#
     pardo a,i,b,j
#
         Tpp[i,j] = 0.0
         do i1
             request VSpipi[a,j,b,i1] 
             request T2old_aa[a,i,b,i1] 
             T1pp[i,j] = VSpipi[a,j,b,i1]*T2old_aa[a,i,b,i1]
             Tpp[i,j] += T1pp[i,j]
         enddo i1
         Tpp[i,j] *= -0.5
         prepare Fii[i,j] += Tpp[i,j]
#
     endpardo a,i,b,j
     pardo a,i,b,j
#
         Tpp[i,j] = 0.0
         do i1
             request Vpiqj[a,j,b,i1] 
             request T2old_ab[a,i,b,i1] 
             T1pp[i,j] = Vpiqj[a,j,b,i1]*T2old_ab[a,i,b,i1]
             Tpp[i,j] += T1pp[i,j]
         enddo i1
         Tpp[i,j] *= -1.0
         prepare Fii[i,j] += Tpp[i,j]
#
     endpardo a,i,b,j
#
     server_barrier
     endproc hbar_ij
#
     proc hbar_ai

     pardo a,i,a1,i1
         request VSpipi[a,i,a1,i1] 

         Taibj[a,i,a1,i1] = VSpipi[a,i,a1,i1]
         T1pp[a1,i1]      = SCai[a1,i1]
         Tpp[a,i]         = Taibj[a,i,a1,i1]*T1pp[a1,i1]

         prepare SFai[a,i] += Tpp[a,i]
     endpardo a,i,a1,i1
     pardo a,i,a1,i1
         request Vpiqj[a,i,a1,i1] 

         Taibj[a,i,a1,i1] = Vpiqj[a,i,a1,i1]
         T1pp[a1,i1]      = SCai[a1,i1]
         Tpp[a,i]         = Taibj[a,i,a1,i1]*T1pp[a1,i1]

         prepare SFai[a,i] += Tpp[a,i]
     endpardo a,i,a1,i1
     server_barrier
     pardo a,i,a1,i1
         request T2old_aa[a,i,a1,i1] 
         request SFai[a1,i1] 
         Taibj[a,i,a1,i1] = T2old_aa[a,i,a1,i1]
         T1pp[a1,i1]      = SFai[a1,i1]
         Tpp[a,i]         = Taibj[a,i,a1,i1]*T1pp[a1,i1]
         prepare Fai[a,i] += Tpp[a,i]
     endpardo a,i,a1,i1
     pardo a,i,a1,i1
         request T2old_ab[a,i,a1,i1] 
         request SFai[a1,i1] 
         Taibj[a,i,a1,i1] = T2old_ab[a,i,a1,i1]
         T1pp[a1,i1]      = SFai[a1,i1]
         Tpp[a,i]         = Taibj[a,i,a1,i1]*T1pp[a1,i1]
         prepare Fai[a,i] += Tpp[a,i]
     endpardo a,i,a1,i1
     server_barrier
#
     endproc hbar_ai
#
     proc hbar_prep
         server_barrier
         pardo a,b
             Tpp[a,b] = 0.0
             prepare Faa[a,b] = Tpp[a,b]
         endpardo a,b
         pardo i,j
             Tpp[i,j] = 0.0
             prepare Fii[i,j] = Tpp[i,j]
         endpardo i,j
         pardo a,i
             Tpp[a,i] = 0.0
             prepare Fai[a,i] = Tpp[a,i]
         endpardo a,i
         pardo a,i
             Tpp[a,i] = 0.0
             prepare SFai[a,i] = Tpp[a,i]
         endpardo a,i
         server_barrier
     endproc hbar_prep
#
     proc make_hbar
#
     call hbar_prep
     call hbar_ab
     call hbar_ij
     call hbar_ai
     server_barrier
#
     endproc make_hbar
#
     proc cisd_energy
#
     server_barrier
     esum2 = 0.0
     esum3 = 0.0
     ecorr2 = 0.0
     edoubles = 0.0
     etriples = 0.0
     ecisccpt2 = 0.0
     server_barrier
#
     pardo a,i,b,j
         request T2old_ab[a,i,b,j] 
         REQUEST CT_ab[a,i,b,j] 
         REQUEST CT_ab[b,i,a,j] 
         Taibj[a,i,b,j]  = CT_ab[a,i,b,j]
         T1aibj[a,i,b,j] = CT_ab[b,i,a,j]
         Taibj[a,i,b,j] *= 2.0
         Taibj[a,i,b,j] -= T1aibj[a,i,b,j]
#
         etemp  = Taibj[a,i,b,j]*T2old_ab[a,i,b,j]
         etemp *= 0.5
         esum2 += etemp
     endpardo a,i,b,j
     pardo a,i
#         request cai(a,i) i
         request Fai[a,i] 
         Tpp[a,i] = Fai[a,i]
#
         do b
             request Faa[a,b] 
#             request cai(b,i) i
             T1pp[a,i] = Faa[a,b]*SCai[b,i]
             Tpp[a,i] += T1pp[a,i]
         enddo b
#
         do j
             request Fii[i,j] 
#             request cai(a,j) a
             T1pp[a,i] = Fii[i,j]*SCai[a,j]
             Tpp[a,i] += T1pp[a,i]
         enddo j
#
         etemp = SCai[a,i]*tpp[a,i]
         esum3+= etemp
#
     endpardo a,i
     server_barrier
#
     collective edoubles += esum2
     collective etriples += esum3
     server_barrier
     ecisccpt2  = edoubles
     ecisccpt2 += etriples
     print edoubles
     print etriples
#
     endproc cisd_energy
#    ------------------------------------------------------------------------ 
# AA t2 amps
    PROC T2oldaa
#
    pardo a,i,b,j
        request T2old_ab[a,i,b,j] 
        request T2old_ab[a,j,b,i] 
        T1aibj[a,i,b,j]  = T2old_ab[a,i,b,j]
        T2aibj[a,i,b,j]  = T2old_ab[a,j,b,i]
        T1aibj[a,i,b,j] -= T2aibj[a,i,b,j]
        prepare T2old_aa[a,i,b,j] = T1aibj[a,i,b,j]
    endpardo a,i,b,j
    server_barrier
#
    ENDPROC T2oldaa
#    ------------------------------------------------------------------------ 
    proc t2new_zero
#
    pardo a,i,b,j
        Taibj[a,i,b,j] = 0.0
        prepare T2new_ab[a,i,b,j] = Taibj[a,i,b,j]
    endpardo a,i,b,j
    server_barrier
#
    endproc t2new_zero
#    ------------------------------------------------------------------------ 
    proc T2newab
#
    pardo a,b,i,j
#
        request Vpiqj[a,i,b,j] 
        Taibj[a,i,b,j]  = Vpiqj[a,i,b,j]
        Taibj[a,i,b,j] *= 0.5
        T1aibj[b,j,a,i] = Taibj[a,i,b,j]
        prepare T2new_ab[a,i,b,j] += Taibj[a,i,b,j]
        prepare T2new_ab[b,j,a,i] += T1aibj[b,j,a,i]
#
    endpardo a,b,i,j
    pardo a,i,b,j
        request CT_ab[a,i,b,j] 
        Taibj[a,i,b,j] = CT_ab[a,i,b,j]
        prepare T2new_ab[a,i,b,j] += Taibj[a,i,b,j]
    endpardo a,i,b,j
#
    endproc T2newab
#    ------------------------------------------------------------------------ 
    proc hhladder_ab
#
    pardo a,b,i1,j1
        request T2old_ab[a,i1,b,j1] 
        do i
            do j
                request Vpiqj[i,i1,j,j1] 
                Taibj[a,i,b,j] = T2old_ab[a,i1,b,j1]*Vpiqj[i,i1,j,j1]
                prepare T2new_ab[a,i,b,j] += Taibj[a,i,b,j]
            enddo j
        enddo i
    endpardo a,b,i1,j1
#
    endproc hhladder_ab
#    ------------------------------------------------------------------------ 
    proc AOppladder_ab

#    First create and zero-out intermediate arrays
#    ---------------------------------------------
#
     PARDO mu, nu, i, j
           Txixj[mu,i,nu,j]           = 0.0
           PREPARE TAO_ab[mu,i,nu,j]  = Txixj[mu,i,nu,j]
           PREPARE T2AO_ab[mu,i,nu,j] = Txixj[mu,i,nu,j]
     ENDPARDO mu, nu, i, j
#
     server_barrier 
#
#    Form Half back transformed cluster arrays  
#    -----------------------------------------
#
#    AB spin combination
#     -------------------
#
     PARDO b, a, j, i
#
           REQUEST T2old_ab[a,i,b,j] 
#
           DO mu
#
              Taixj[a,i,mu,j] = T2old_ab[a,i,b,j]*ca[mu,b]
#
              DO nu
#
                 Txixj[nu,i,mu,j]           = Taixj[a,i,mu,j]*ca[nu,a]
                 PREPARE TAO_ab[nu,i,mu,j] += Txixj[nu,i,mu,j]
#
              ENDDO nu
#
           ENDDO mu
#
      ENDPARDO b, a, j, i
#
     server_barrier   
#
#    Contract AOINT with half back transformed Amplitudes 
#    ----------------------------------------------------    
#
     PARDO mu, nu, lambda, sigma
        WHERE mu < nu 
#
           execute compute_integral_batch aoint[lambda,mu,sigma,nu] 
#
           DO i
           DO j
#
              REQUEST                       TAO_ab[lambda,i,sigma,j] 
              Yab[mu,i,nu,j]              = aoint[lambda,mu,sigma,nu]*TAO_ab[lambda,i,sigma,j]
              Y1ab[nu,j,mu,i]             = Yab[mu,i,nu,j]
#
              PREPARE T2AO_ab[mu,i,nu,j] += Yab[mu,i,nu,j]
              PREPARE T2AO_ab[nu,j,mu,i] += Y1ab[nu,j,mu,i]
#
           ENDDO j
           ENDDO i
#
     ENDPARDO mu, nu, lambda, sigma
#
     PARDO mu, nu, lambda, sigma
        WHERE mu == nu 
#
           execute compute_integral_batch aoint[lambda,mu,sigma,nu] 
#
           DO i
           DO j
#
              REQUEST                       TAO_ab[lambda,i,sigma,j] 
              Yab[mu,i,nu,j]              = aoint[lambda,mu,sigma,nu]*TAO_ab[lambda,i,sigma,j]
              PREPARE T2AO_ab[mu,i,nu,j] += Yab[mu,i,nu,j]
#
           ENDDO j
           ENDDO i
#
     ENDPARDO mu, nu, lambda, sigma
#
     server_barrier  
#
#    Perform final transformation
#    ----------------------------
#
        PARDO nu, i, j
#
              allocate LDaixj[*,i,nu,j]
#
              DO mu
#
                 REQUEST T2AO_ab[mu,i,nu,j] 
#
                 DO a
                    Taixj[a,i,nu,j]   = T2AO_ab[mu,i,nu,j]*ca[mu,a]
                    LDaixj[a,i,nu,j] += Taixj[a,i,nu,j]
                 ENDDO a
#
              ENDDO mu
#
              DO a
                 PREPARE TDaixj[a,i,nu,j] = LDaixj[a,i,nu,j]
              ENDDO a
#
              deallocate LDaixj[*,i,nu,j]
#
        ENDPARDO nu, i, j
        server_barrier
#
        PARDO a, i, j, nu
#
              REQUEST TDaixj[a,i,nu,j] 
#
              DO b
#
                 Taibj[a,i,b,j]             = TDaixj[a,i,nu,j]*ca[nu,b]
#
                 PREPARE T2new_ab[a,i,b,j] += Taibj[a,i,b,j]
#
              ENDDO b
#
        ENDPARDO a, i, j, nu
#
        sip_barrier
    endproc AOppladder_ab
#
#    ------------------------------------------------------------------------ 
    proc phladder_ab
#
      PARDO j, b, a, i
            Taibj[a,i,b,j] = 0.0
#
            DO i1
            DO a1
#
               REQUEST              Viaai[i,a,a1,i1] 
               REQUEST              Vaaii[a1,a,i,i1] 
               REQUEST              T2old_ab[a1,i1,b,j] 

               TYaiai[a,i,a1,i1]   = 0.0
#
               Taiai[a,i,a1,i1]    = Vaaii[a1,a,i,i1]
               TYaiai[a,i,a1,i1]  -= Taiai[a,i,a1,i1]
               Taiai[a,i,a1,i1]    = Viaai[i,a,a1,i1]
               TYaiai[a,i,a1,i1]  += Taiai[a,i,a1,i1]
#
               R1aibj[a,i,b,j]     = TYaiai[a,i,a1,i1]*T2old_ab[a1,i1,b,j]
               Taibj[a,i,b,j]     += R1aibj[a,i,b,j]
#
            ENDDO a1
            ENDDO i1

            R1aibj[b,j,a,i]            = taibj[a,i,b,j]
            PREPARE T2new_ab[a,i,b,j] += taibj[a,i,b,j]
            PREPARE T2new_ab[b,j,a,i] += R1aibj[b,j,a,i]
#
      ENDPARDO j, b, a, i
#
      PARDO i1, a1, a, i
            REQUEST                     T2old_ab[a1,i1,a,i] 
            REQUEST                     T2old_ab[a1,i,a,i1] 
            taiai[a1,i1,a,i]          = T2old_ab[a1,i1,a,i]
            t1aiai[a1,i1,a,i]         = T2old_ab[a1,i,a,i1]
            taiai[a1,i1,a,i]         -= t1aiai[a1,i1,a,i]
            tpppp[a1,i1,i,a]          = taiai[a1,i1,a,i]
#
            DO j
            DO b
#
               REQUEST                        Viaai[i,a,b,j] 
               R1aibj[a1,i1,b,j]            = tpppp[a1,i1,i,a]*Viaai[i,a,b,j]
               Taibj[b,j,a1,i1]             = R1aibj[a1,i1,b,j]
               PREPARE T2new_ab[a1,i1,b,j] += R1aibj[a1,i1,b,j]
               PREPARE T2new_ab[b,j,a1,i1] += Taibj[b,j,a1,i1]
#
            ENDDO b
            ENDDO j
#
      ENDPARDO i1, a1, a, i
#
      PARDO a, j, i1, b1
#
            REQUEST T2old_ab[a,i1,b1,j] 
#
            DO i
            DO b
#
               REQUEST                      Vaaii[b,b1,i1,i] 
#
               Taibj[a,i,b,j]             = T2old_ab[a,i1,b1,j]*Vaaii[b,b1,i1,i]
               Taibj[a,i,b,j]            *= -1.0
#
               T2aibj[b,j,a,i]            = Taibj[a,i,b,j]
               PREPARE T2new_ab[a,i,b,j] += Taibj[a,i,b,j]
               PREPARE T2new_ab[b,j,a,i] += T2aibj[b,j,a,i]
#
            ENDDO b
            ENDDO i
#
      ENDPARDO a, j, i1, b1
#
    endproc phladder_ab
#    ------------------------------------------------------------------------ 
#    ------------------------------------------------------------------------ 
#    ------------------------------------------------------------------------ 
#    ------------------------------------------------------------------------ 
    proc updatet2
#
      PARDO b, a, j, i
#
            REQUEST                    T2old_ab[b,j,a,i] 
            REQUEST                    T2new_ab[b,j,a,i] 
            Taibj[a,i,b,j]           = T2new_ab[b,j,a,i]
            T1aibj[a,i,b,j]          = T2old_ab[b,j,a,i]
#
            REQUEST                    T2old_ab[a,i,b,j] 
            REQUEST                    T2new_ab[a,i,b,j] 
            Taibj[a,i,b,j]          += T2new_ab[a,i,b,j]
            T1aibj[a,i,b,j]         += T2old_ab[a,i,b,j]

            execute energy_denominator_rhf Taibj[a,i,b,j] fock_a
            T1aibj[a,i,b,j] -= Taibj[a,i,b,j]
            T1aibj[a,i,b,j] *= -0.5

            if niter < diis_order
               PREPARE Eaibj[a,i,b,j,kiter] = T1aibj[a,i,b,j]
            endif

            if niter >= diis_order
               kcount = 0.0
               DO jdiis
                  kcount += 1.0
                  if kcount == diis_order
                     PREPARE Eaibj[a,i,b,j,jdiis] = T1aibj[a,i,b,j]
                     exit
                  endif
               ENDDO jdiis
            endif
      ENDPARDO b, a, j, i
      server_barrier
#
      PARDO b, a, j, i
#
            REQUEST                    T2new_ab[a,i,b,j] 
            REQUEST                    T2new_ab[b,j,a,i] 
            Taibj[a,i,b,j]           = T2new_ab[b,j,a,i]
            Taibj[a,i,b,j]          += T2new_ab[a,i,b,j]
            Taibj[a,i,b,j]          *= 0.5
            execute energy_denominator_rhf Taibj[a,i,b,j] fock_a
            PREPARE T2old_ab[a,i,b,j]    = Taibj[a,i,b,j]
#
      ENDPARDO b, a, j, i
#
    endproc updatet2
#    ------------------------------------------------------------------------ 
      PROC DIISN
#     ---------- 

      create DIST_BB
      worder = niter
      if niter >= diis_order
         worder = diis_order
      endif
      server_barrier
      PARDO a, i, b, j
         kcount = 0.0
         DO jdiis
            kcount += 1.0
            if kcount <= worder

               REQUEST Eaibj[a,i,b,j,jdiis] 
               REQUEST Eaibj[a,j,b,i,jdiis] 

               t1aibj[a,i,b,j] = Eaibj[a,i,b,j,jdiis]
               t3aibj[a,j,b,i] = Eaibj[a,j,b,i,jdiis]
               t2aibj[a,i,b,j] = t3aibj[a,j,b,i]
               t1aibj[a,i,b,j]-= t2aibj[a,i,b,j]

         jcount = 0.0
         DO j1diis
            jcount += 1.0
            if jcount <= worder

               REQUEST Eaibj[a,i,b,j,j1diis] 
               REQUEST Eaibj[a,j,b,i,j1diis] 

               t3aibj[a,i,b,j] = Eaibj[a,i,b,j,j1diis]
               t2aibj[a,j,b,i] = Eaibj[a,j,b,i,j1diis]
               t4aibj[a,i,b,j] = t2aibj[a,j,b,i]
               t3aibj[a,i,b,j]-= t4aibj[a,i,b,j]

               tbb[jdiis,j1diis]          = Eaibj[a,i,b,j,jdiis]*Eaibj[a,i,b,j,j1diis]
               tbb[jdiis,j1diis]         *= 2.0
               PUT DIST_BB[jdiis,j1diis] += tbb[jdiis,j1diis]

               etemp                     = t1aibj[a,i,b,j]*t3aibj[a,i,b,j]
               tbb[jdiis,j1diis]          = etemp
               PUT DIST_BB[jdiis,j1diis] += tbb[jdiis,j1diis]
            endif
         ENDDO j1diis
            endif # kcount <= diis_order  
         ENDDO jdiis
      ENDPARDO a, i, b, j
      server_barrier

      jcount = 0.0
      DO jdiis
         jcount += 1.0
         if jcount <= worder
      kcount = 0.0
      DO j1diis
         kcount += 1.0
         if kcount <= worder
            GET DIST_BB[jdiis,j1diis]
            BB[jdiis,j1diis] = DIST_BB[jdiis,j1diis]
         endif
      ENDDO j1diis
         endif
      ENDDO jdiis

      execute compute_diis BB
      temp_order = worder
      server_barrier
      PARDO a, i, b, j
            taibj[a,i,b,j] = 0.0
            n1 = 0.0
            DO kdiis
               n1 += 1.0
               if n1 <  worder # temp_order # VFL  
                  REQUEST           Daibj[a,i,b,j,kdiis] 
                  t2aibj[a,i,b,j] = Daibj[a,i,b,j,kdiis]
                  n2 = 0.0
                  DO d2
                    n2 += 1.0
                    if n2 <= worder
                      kcount  = n2
                      kcount -= n1
                      if kcount == one
                         REQUEST           Eaibj[a,i,b,j,d2] 
                         t3aibj[a,i,b,j] = Eaibj[a,i,b,j,d2]
                         execute return_sval BB[d2,d2] etemp
                        #etemp        = BB(d1,d1)        
                         t3aibj[a,i,b,j] += t2aibj[a,i,b,j]
                         t3aibj[a,i,b,j] *= etemp
                         taibj[a,i,b,j]  += t3aibj[a,i,b,j]
                      endif
                    endif #n2 <= worder 
                   ENDDO d2
               endif
            ENDDO kdiis

            n2 = 0.0
            DO d2
               n2 += 1.0
               if n2 == one
                  REQUEST           D0aibj[a,i,b,j] 
                  t2aibj[a,i,b,j] = D0aibj[a,i,b,j]
                  REQUEST           Eaibj[a,i,b,j,d2] 
                  t3aibj[a,i,b,j] = Eaibj[a,i,b,j,d2]
                  execute return_sval BB[d2,d2] etemp
                 #etemp        = BB(d1,d1)        
                  t3aibj[a,i,b,j] += t2aibj[a,i,b,j]
                  t3aibj[a,i,b,j] *= etemp
                  taibj[a,i,b,j]  += t3aibj[a,i,b,j]
               endif
            ENDDO d2

            PREPARE T2old_ab[a,i,b,j] = taibj[a,i,b,j]
      ENDPARDO a, i, b, j
      server_barrier

# If history space is full shift history end error vectors 

      if niter >= diis_order

# histories first 

      PARDO a, i, b, j
      n1 = 0.0
      DO kdiis
         n1 += 1.0
         if n1 <  worder # temp_order # VFL 
         REQUEST Daibj[a,i,b,j,kdiis] 
         taibj[a,i,b,j] = Daibj[a,i,b,j,kdiis]
         n2 = 0.0
      DO k1diis
         n2 += 1.0
         etemp = n1
         etemp -= n2
         if etemp == 1.0
            PREPARE Daibj[a,i,b,j,k1diis] = taibj[a,i,b,j]
         endif
         if n1 == one
            PREPARE D0aibj[a,i,b,j] = taibj[a,i,b,j]
         endif
      ENDDO k1diis
         endif
      ENDDO kdiis
      ENDPARDO a, i, b, j
# Now error vectors 

      PARDO a, i, b, j
      n1 = 0.0
      DO kdiis
         n1 += 1.0
         if n1 <= worder # temp_order # VFL 
         REQUEST Eaibj[a,i,b,j,kdiis] 
         taibj[a,i,b,j] = Eaibj[a,i,b,j,kdiis]
         n2 = 0.0
      DO k1diis
         n2 += 1.0
         etemp = n1
         etemp -= n2
         if etemp == 1.0
            PREPARE Eaibj[a,i,b,j,k1diis] = taibj[a,i,b,j]
         endif
      ENDDO k1diis
         endif
      ENDDO kdiis
      ENDPARDO a, i, b, j


      endif
      server_barrier
      delete DIST_BB

      ENDPROC DIISN
#
      proc clear_diis
#
      do d1
      do d2
          Tbb[d1,d2] = 0.0
          BB[d1,d2] = 0.0
      enddo d2
      enddo d1
      pardo a,i,b,j
          Taibj[a,i,b,j] = 0.0
          prepare D0aibj[a,i,b,j] = Taibj[a,i,b,j]
      endpardo a,i,b,j
      pardo a,i,b,j,kdiis
          Taibjk[a,i,b,j,kdiis] = 0.0
          prepare Daibj[a,i,b,j,kdiis] = Taibjk[a,i,b,j,kdiis]
      endpardo a,i,b,j,kdiis
      pardo a,i,b,j,kdiis
          Taibjk[a,i,b,j,kdiis] = 0.0
          prepare Eaibj[a,i,b,j,kdiis] = Taibjk[a,i,b,j,kdiis]
      endpardo a,i,b,j,kdiis
#
      server_barrier
      endproc clear_diis
#     -------------
      PROC MOVET2
#     ------------
#
      PARDO b, a, j, i
#
            REQUEST                    T2old_ab[a,i,b,j] 
            Taibj[a,i,b,j]           = T2old_ab[a,i,b,j]

            if niter < diis_order
               PREPARE Daibj[a,i,b,j,kiter] = Taibj[a,i,b,j]
            endif

            if niter >= diis_order
               kcount = 1.0
               DO kdiis
                  kcount += 1.0
                  if kcount == diis_order
                     PREPARE Daibj[a,i,b,j,kdiis] = Taibj[a,i,b,j]
                     exit
                  endif
               ENDDO kdiis
            endif
      ENDPARDO b, a, j, i
#
      ENDPROC MOVET2
#
#    ------------------------------------------------------------------------ 
#           MAIN
#    ------------------------------------------------------------------------ 

print " "
print "-- Parallel CIS-CCPT(2) program"
print "-- J Chem Phys 2014, 140, 234108."
print "-- Written by Jason N. Byrd, 2014"
print "  " 

    master = 0
    ecrit = cc_conv
    zero = 0.0
    one = 1.0
    two = 2.0
    five  = 5.0
    six   = 6.0
    seven = 7.0
#
    diis_start = 2.0
    diis_order = 8.0
    print diis_start
    print diis_order
    server_barrier

# Initilize the vaiable to zmax and imax (memory of ERD and OED).
zmax = 0.0
imax = 0.0
execute compute_int_scratchmem oed_ovl zmax imax
#
    call read_2el
    server_barrier
    call energy_start
    lccd_energy = ecorrT
    print lccd_energy
# second-order starting guess for the T2 amps
#
      kroot = 1.0
      do kstate
          server_barrier
          print " "
          print kroot
#
          server_barrier
          call iguess_uhf
          server_barrier
          call setroot
          call Caibj
          server_barrier

          kroot += 1.0
#
	eold = 0.0
	niter = 0.0
	do kiter
	    print " "
	    print kiter
	    niter += 1.0
	    server_barrier
#
	    call t2new_zero
#
	    call t2newab
#
	    call hhladder_ab # hh
	    call phladder_ab # ph
	    call AOppladder_ab # pp
	    server_barrier
#
	    call updatet2
	    server_barrier
	    call make_hbar
	    call cisd_energy
	    server_barrier
	    call energy
            Ekd[kstate] = ecorrT
	    server_barrier
#
	    if niter >= diis_start
		call diisn
	    endif
	    call movet2
	    server_barrier
	    assert_same ecorrT
	    assert_same eold
	    ediff = eold - ecorrT
	    etemp = ediff**2.0
	    ediff = etemp**(0.5)
	    assert_same ediff
	    IF ediff < ecrit
	       exit # kiter 
	    ENDIF
#
#        Reset eold --> enew 
#        ------------------- 
#
	    eold = ecorrT
#
	enddo kiter
#
	call clear_diis
#
	server_barrier

      enddo kstate
#
      print " "
      print "CIS-CCPT(2) complete"
      print "FINAL Excitation energies"
      do kstate
  	allocate contiguous CISCCPT2_EE_Energy[kstate:kstate]
	etemp = Ekd[kstate]
	esum2 = Ek[kstate]
	etemp += esum2
	etemp -= lccd_energy
  	CISCCPT2_EE_Energy[kstate:kstate] = etemp
	print CISCCPT2_EE_Energy[kstate:kstate]
	deallocate contiguous CISCCPT2_EE_Energy[kstate:kstate]
      enddo kstate
#
      server_barrier
#
      server_barrier
      set_persistent     ca    "ca" 
      set_persistent     Fock_a "fock_a"
      set_persistent     T2old_ab "T2old_ab"
      set_persistent     Viaai  "Viaai"
      set_persistent     Vaaii  "Vaaii"
      set_persistent     Vpiqj  "Vpiqj"
      set_persistent     VSpipi "VSpipi"
      set_persistent     ck0 "C1_a"
      set_persistent     Ek "CIS_E"
#
#    ------------------------------------------------------------------------ 
                           ENDSIAL CCSD_RHF_SV1
